---
description: unit test - Complete rules for unit testing with design problem detection and refactoring guidance
alwaysApply: true
---

# Unit Testing Rules - Le Bon Prix

## üéØ PRIMARY OBJECTIVE

You are an expert unit testing specialist for the Le Bon Prix application. Your mission is to:
1. **IDENTIFY design problems BEFORE writing tests**
2. **REFACTOR problematic code to make it testable**
3. **WRITE quality tests that reveal real problems**
4. **MAINTAIN consistency in mocks, fixtures, and patterns**

**IMPORTANT**: Never write tests that "pass" by masking problems. Tests must reveal design issues and guide refactoring.

---

## üìã MANDATORY WORKFLOW BEFORE ANY TEST

### STEP 1: COMPLETE CODE ANALYSIS (MANDATORY)

**BEFORE writing any test**, you MUST:

1. **Read and analyze the complete source code**:
   - The file/service/component to test
   - All its imports and dependencies
   - Related files (types, utilities, services)
   - Hooks or contexts used

2. **Identify design problems** using the checklist below

3. **Document found problems** in a comment at the beginning of the test file

4. **Decide on necessary refactoring** before writing tests

### MANDATORY ANALYSIS CHECKLIST

For each file to test, verify:

#### üî¥ CRITICAL PROBLEM 1: Strong coupling with Firebase
- [ ] Does the file directly import `db`, `auth`, or `storage` from `firebase.ts`?
- [ ] Are there direct calls to `collection()`, `doc()`, `getDoc()`, etc.?
- [ ] Do components/pages directly access Firebase?

**If YES** ‚Üí **REFACTOR BEFORE tests**:
- Create an abstract service (e.g., `ProductRepository`, `SaleRepository`)
- Inject the repository as a dependency
- Source code must use the repository, not Firebase directly

**Refactoring example**:
```typescript
// ‚ùå BAD (needs refactoring)
import { db } from '../services/firebase';
const productRef = doc(db, 'products', id);

// ‚úÖ GOOD (after refactoring)
import { ProductRepository } from '../services/repositories/ProductRepository';
const product = await productRepository.getById(id);
```

#### üî¥ CRITICAL PROBLEM 2: Business logic in components/pages
- [ ] Are there complex calculations (profit, totals, statistics) in components?
- [ ] Is business logic mixed with UI logic?
- [ ] Are calculation functions reusable elsewhere?

**If YES** ‚Üí **EXTRACT BEFORE tests**:
- Create pure functions in `src/utils/` or `src/services/calculations/`
- Functions must be testable without React/Firebase
- Components call these functions, don't contain them

**Refactoring example**:
```typescript
// ‚ùå BAD (in Finance.tsx)
const profit = useMemo(() => {
  return filteredSales.reduce((sum, sale) => {
    return sum + sale.products.reduce((productSum, product) => {
      // ... 20 lines of calculations
    }, 0);
  }, 0);
}, [filteredSales, products, stockChanges]);

// ‚úÖ GOOD (extract to utils/financialCalculations.ts)
export const calculateProfit = (
  sales: Sale[],
  products: Product[],
  stockChanges: StockChange[]
): number => {
  // Pure logic, testable
};

// In Finance.tsx
const profit = useMemo(
  () => calculateProfit(filteredSales, products, stockChanges),
  [filteredSales, products, stockChanges]
);
```

#### üî¥ CRITICAL PROBLEM 3: Functions with too many responsibilities
- [ ] Does the function do more than 3 different things?
- [ ] Are there more than 5 parameters?
- [ ] Does the function do validation + calculations + DB + audit + others?

**If YES** ‚Üí **DECOMPOSE BEFORE tests**:
- Separate into smaller functions with single responsibility
- Use configuration objects instead of many parameters
- Create intermediate functions testable individually

**Refactoring example**:
```typescript
// ‚ùå BAD (createSale does everything)
export const createSale = async (data, companyId) => {
  // Validation (20 lines)
  // Calculations (30 lines)
  // Batch operations (40 lines)
  // Audit logs (10 lines)
  // Stock updates (20 lines)
  // Total: 120+ lines
};

// ‚úÖ GOOD (decomposed)
export const validateSaleData = (data, products) => { /* ... */ };
export const calculateSaleTotals = (products, stockBatches) => { /* ... */ };
export const createSaleTransaction = async (saleData, batch) => { /* ... */ };
export const createSale = async (data, companyId) => {
  const validation = validateSaleData(data, products);
  const totals = calculateSaleTotals(data.products, batches);
  return createSaleTransaction({ ...data, ...totals }, batch);
};
```

#### üü° MEDIUM PROBLEM 4: Overly complex hooks
- [ ] Is the hook more than 300 lines?
- [ ] Does it mix multiple responsibilities (state + API + localStorage + sync)?
- [ ] Is it difficult to understand in one reading?

**If YES** ‚Üí **SIMPLIFY DURING tests**:
- Extract business logic into separate functions
- Create smaller, specialized hooks
- Use composed hooks

#### üü° MEDIUM PROBLEM 5: Code duplication
- [ ] Are calculations repeated in multiple files?
- [ ] Is validation duplicated?
- [ ] Are Firebase patterns repeated?

**If YES** ‚Üí **EXTRACT DURING tests**:
- Create reusable utilities
- Use helper functions
- Create factories for repeated patterns

---

## üèóÔ∏è REQUIRED TEST ARCHITECTURE

### File Structure (MANDATORY)

```
src/
‚îú‚îÄ‚îÄ __tests__/
‚îÇ   ‚îú‚îÄ‚îÄ setup.ts                    # Global test setup
‚îÇ   ‚îú‚îÄ‚îÄ mocks/                      # Standardized mocks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ firebase.ts            # Complete Firebase mocks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ repositories.ts        # Abstract repository mocks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ localStorage.ts        # localStorage mocks
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ fixtures/              # Standardized test data
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ products.ts
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ sales.ts
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ companies.ts
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ users.ts
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ render.tsx              # Custom render with providers
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test-utils.ts           # Test helpers
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ [feature]/              # Feature-specific test folder
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ [feature].test.ts   # Test file
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ MANUAL_VERIFICATION.md  # Manual testing guide
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ [service]/              # Service-specific test folder
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ [service].test.ts   # Test file
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ MANUAL_VERIFICATION.md  # Manual testing guide
‚îÇ   ‚îî‚îÄ‚îÄ components/
‚îÇ       ‚îî‚îÄ‚îÄ [component]/            # Component-specific test folder
‚îÇ           ‚îú‚îÄ‚îÄ [component].test.tsx # Test file
‚îÇ           ‚îî‚îÄ‚îÄ MANUAL_VERIFICATION.md  # Manual testing guide
```

### Test Folder Organization (MANDATORY)

Each test MUST be in its own folder containing:
1. **Test file**: `[name].test.ts` or `[name].test.tsx`
2. **Manual verification guide**: `MANUAL_VERIFICATION.md`

Example:
```
src/__tests__/utils/security/
  ‚îú‚îÄ‚îÄ security.test.ts            # Automated tests
  ‚îî‚îÄ‚îÄ MANUAL_VERIFICATION.md      # Manual testing guide
```

### Naming Conventions (MANDATORY)

- **Test folders**: `src/__tests__/[category]/[feature]/`
- **Test files**: `[FileName].test.ts` or `[FileName].test.tsx`
- **Manual guides**: `MANUAL_VERIFICATION.md` (always uppercase)
- **Test suites**: `describe('[Component/Function Name]', () => {})`
- **Tests**: `it('should [expected behavior]', () => {})`
- **Mocks**: `mock[FunctionName]` or `vi.fn()` with descriptive name
- **Fixtures**: `mock[Type]` or `createMock[Type]()` for factories

---

## üîß MOCKING STANDARDS

### 1. Firebase/Firestore (MANDATORY)

**NEVER** mock Firebase directly in individual tests.

**USE** centralized mocks from `src/__tests__/mocks/firebase.ts`:

```typescript
// ‚úÖ GOOD - Use centralized mocks
import { mockFirestore, mockAuth } from '@/__tests__/mocks/firebase'

beforeEach(() => {
  vi.clearAllMocks()
  mockFirestore.collection.mockReturnValue({
    doc: vi.fn().mockReturnValue({
      get: vi.fn().mockResolvedValue({
        exists: () => true,
        data: () => mockProduct
      })
    })
  })
})
```

**FOR abstract repositories** (after refactoring):

```typescript
// ‚úÖ GOOD - Mock the abstract repository
import { ProductRepository } from '@/services/repositories/ProductRepository'

vi.mock('@/services/repositories/ProductRepository', () => ({
  ProductRepository: {
    getById: vi.fn(),
    create: vi.fn(),
    update: vi.fn()
  }
}))
```

### 2. localStorage (MANDATORY)

```typescript
import { mockLocalStorage } from '@/__tests__/mocks/localStorage'

beforeEach(() => {
  mockLocalStorage.clear()
})
```

### 3. Test Data Fixtures (MANDATORY)

**USE** factories to create test data:

```typescript
import { createMockProduct, createMockSale } from '@/__tests__/mocks/fixtures'

// ‚úÖ GOOD - Use factories
const product = createMockProduct({ name: 'Test Product', stock: 100 })

// ‚ùå BAD - Hardcoded data
const product = { id: '1', name: 'Test', stock: 100, /* ... 20 properties */ }
```

---

## üìù MANDATORY TEST STRUCTURE

### Creating a New Test (Step-by-Step)

When creating tests for any file, follow these steps:

1. **Create test folder**: `src/__tests__/[category]/[feature]/`
2. **Create test file**: `[feature].test.ts` in the folder
3. **Create manual guide**: `MANUAL_VERIFICATION.md` in the folder
4. **Write automated tests**: Follow template below
5. **Write manual guide**: Follow manual verification template

### Template for each test file

```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest'

/**
 * PROBLEMS IDENTIFIED BEFORE TESTS:
 * 
 * 1. [Problem 1] - [Solution applied]
 * 2. [Problem 2] - [Solution applied]
 * 
 * REFACTORING PERFORMED:
 * - [List of refactorings]
 */

describe('[Component/Function Name]', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    // Specific setup
  })

  describe('Main behavior', () => {
    it('should [expected behavior]', () => {
      // Arrange
      // Act
      // Assert
    })
  })

  describe('Edge cases', () => {
    it('should handle [edge case]', () => {
      // Test
    })
  })

  describe('Error handling', () => {
    it('should handle [error] gracefully', () => {
      // Test
    })
  })
})
```

### Template for MANUAL_VERIFICATION.md

```markdown
# Manual Verification Guide
## [Feature Name] - [Source File Path]

**Test File**: `[test-file-name].test.ts`  
**Source File**: `[source-file-path]`  
**Last Updated**: [Date]

---

## üìã Overview

Brief description of what this file does and why manual verification is needed.

---

## üéØ Functions/Components to Verify

1. `functionName1()` - Brief description
2. `functionName2()` - Brief description

---

## 1Ô∏è‚É£ Function/Component Name

### Function Purpose
What this function does

### Where It's Used
- File 1 - Context
- File 2 - Context

### Manual Verification Steps

#### Step 1: [Action]
1. Navigate to [location]
2. Perform [action]
3. Observe [result]

#### Step 2: Check Console Log
```javascript
// Expected console output
console.log('Expected message', expectedValue)
```

#### Step 3: Check Toast Notifications
- ‚úÖ Success toast: "[Success message]"
- ‚ùå Error toast: "[Error message]"
- ‚ÑπÔ∏è Info toast: "[Info message]"

#### Step 4: Verify in Database (Firestore/Other)
1. Open database console
2. Navigate to [collection/table]
3. Verify [field] contains [expected value]

#### Expected Results
- ‚úÖ [Expected result 1]
- ‚úÖ [Expected result 2]
- ‚úÖ [Expected result 3]

#### Edge Cases to Test
| Test Case | Input | Expected Output |
|-----------|-------|-----------------|
| Normal | value | result |
| Edge | value | result |

---

## üîç Common Issues & Troubleshooting

### Issue 1: [Problem]
**Symptom**: [What user sees]

**Check**:
1. [Thing to check]
2. [Thing to check]

**Solution**: [How to fix]

---

## üìä Test Checklist

- [ ] Console logs show expected output
- [ ] Toast notifications appear correctly
- [ ] Database updates are correct
- [ ] UI reflects changes properly
- [ ] No errors in browser console

---

**Last Verified**: [Date]  
**Verified By**: [Name/Team]  
**Status**: ‚úÖ All tests passing
```
```

---

## üéØ REQUIRED TEST CATEGORIES

For each function/component, test:

1. **Main behavior** - Normal use case
2. **Edge cases** - Null, empty, extreme values
3. **Error handling** - Network errors, validation, permissions
4. **Business edge cases** - Specific domain cases
5. **Integrations** - Interactions with other services (if needed)

---

## üö® CRITICAL RULES

### RULE 1: Never write tests that mask problems

**‚ùå BAD**:
```typescript
// Test that passes by mocking everything, masking strong coupling
it('should create sale', async () => {
  vi.mock('firebase/firestore') // Direct mock = masks the problem
  // Test passes but code remains poorly designed
})
```

**‚úÖ GOOD**:
```typescript
// First refactor to use a repository
// Then test the abstract repository
it('should create sale via repository', async () => {
  const saleRepository = new SaleRepository(mockFirestore)
  // Test reveals real problems
})
```

### RULE 2: Tests must guide refactoring

If a test is difficult to write:
1. **STOP** writing the test
2. **IDENTIFY** why it's difficult
3. **REFACTOR** the code to make it testable
4. **THEN** write the test

### RULE 3: Mock consistency

- **ALWAYS** use centralized mocks
- **NEVER** create ad-hoc mocks in each test
- **ALWAYS** use standardized fixtures

### RULE 4: Test behavior, not implementation

**‚ùå BAD**:
```typescript
it('should call Firebase collection with "products"', () => {
  // Tests implementation, not behavior
})
```

**‚úÖ GOOD**:
```typescript
it('should retrieve product by ID', async () => {
  // Tests expected behavior
})
```

---

## üìä COVERAGE REQUIREMENTS

- **Utility functions**: 95%+ (pure logic, easy to test)
- **Services/Repositories**: 90%+ (after refactoring)
- **Custom hooks**: 85%+ (after simplification)
- **Components**: 80%+ (after extracting business logic)
- **Overall project**: 85%+

---

## üîÑ TEST-GUIDED REFACTORING PROCESS

### When identifying a problem during tests:

1. **DOCUMENT** the problem in a comment
2. **CREATE a refactoring issue** (in comments)
3. **WRITE the test for current behavior** (even if code is bad)
4. **REFACTOR** the code
5. **VERIFY** tests still pass
6. **IMPROVE** tests if necessary

### Refactoring comment example:

```typescript
/**
 * TODO REFACTORING: This function is difficult to test because:
 * 1. It mixes validation + calculations + DB + audit
 * 2. It has 8 parameters (should use a config object)
 * 3. It directly accesses Firebase (should use a repository)
 * 
 * REFACTORING PLAN:
 * - Extract validateSaleData()
 * - Extract calculateSaleTotals()
 * - Create SaleRepository for DB operations
 * - Simplify createSale() to orchestrate extracted functions
 */
```

---

## üìö MANDATORY REFERENCES

Before writing tests, consult:
1. `docs/UNIT_TESTING_IMPLEMENTATION_GUIDE.md` - Complete guide
2. `docs/UNIT_TESTING_STATUS.md` - Current test status
3. `src/__tests__/mocks/` - Available mocks
4. `src/__tests__/utils/fixtures/` - Available fixtures

---

## ‚úÖ CHECKLIST BEFORE SUBMITTING A TEST

- [ ] Complete code analysis performed
- [ ] Design problems identified and documented
- [ ] Critical refactoring performed (if necessary)
- [ ] Tests written for behavior, not implementation
- [ ] Centralized mocks used
- [ ] Standardized fixtures used
- [ ] All tests pass
- [ ] Required coverage achieved
- [ ] Documentation updated

---

## üéØ COMPLETE EXAMPLE: Process for testing `createSale`

### STEP 1: Analysis

```typescript
// Analyze createSale in firestore.ts
// Identify:
// 1. ‚úÖ Strong coupling with Firebase (direct db import)
// 2. ‚úÖ Too many responsibilities (validation + calculations + DB + audit)
// 3. ‚úÖ Function too long (140 lines)
// 4. ‚úÖ Business logic mixed with DB operations
```

### STEP 2: Necessary refactoring

```typescript
// Create:
// 1. SaleValidationService (pure validation)
// 2. SaleCalculationService (pure calculations)
// 3. SaleRepository (abstract DB operations)
// 4. Refactor createSale to orchestrate these services
```

### STEP 3: Tests

```typescript
// Test:
// 1. SaleValidationService.test.ts (pure tests, fast)
// 2. SaleCalculationService.test.ts (pure tests, fast)
// 3. SaleRepository.test.ts (with Firebase mocks)
// 4. createSale.test.ts (light integration tests)
```

---

## üîç AUTOMATIC PROBLEM DETECTION

### Patterns to automatically detect:

1. **Direct Firebase imports**:
   - `import { db, auth, storage } from '../services/firebase'`
   - `import { collection, doc } from 'firebase/firestore'` in components/pages

2. **Functions too long**:
   - More than 50 lines = suspect
   - More than 100 lines = critical problem

3. **Too many parameters**:
   - More than 5 parameters = use a config object

4. **Calculations in useMemo/useEffect**:
   - More than 10 lines of calculations = extract to a function

5. **Overly complex hooks**:
   - More than 300 lines = simplify

---

---

## üìã MANUAL VERIFICATION REQUIREMENTS

### Purpose of Manual Verification Guides

Every test folder MUST include a `MANUAL_VERIFICATION.md` file that provides:
1. **UI Testing Instructions** - How to verify the functionality in the user interface
2. **Toast Notification Checks** - What success/error messages should appear
3. **Console Log Verification** - What should be logged and when
4. **Database Verification** - How to verify data in Firestore/database
5. **Edge Case Testing** - Manual tests for edge cases

### What to Include in Manual Guides

#### 1. UI Testing Steps
- Clear step-by-step instructions
- Screenshots or descriptions of where to click
- What user actions trigger the function
- What should appear on screen

#### 2. Toast Notifications
```markdown
- ‚úÖ Success: "Employee added successfully"
- ‚ùå Error: "Failed to add employee: Invalid email"
- ‚ÑπÔ∏è Info: "Generating employee ID..."
- ‚ö†Ô∏è Warning: "Employee already exists"
```

#### 3. Console Logs
```javascript
// What should appear in browser console
console.log('Generated password:', 'John123Doe')
console.error('Error creating employee:', error)
```

#### 4. Database Checks
```markdown
**Firestore Path**: `companies/{companyId}/employees/{employeeId}`
**Expected Fields**:
- id: "emp_1700000000000_abc123"
- firstname: "John"
- hashedPassword: "[64-char hex string]"
```

#### 5. Edge Cases
Tables showing inputs and expected outputs for manual testing

### When Manual Verification is Critical

Manual verification is ESPECIALLY important for:
- User-facing features (forms, modals, pages)
- Payment processing
- Authentication and authorization
- Data creation/modification
- File uploads
- External API integrations
- Real-time updates (websockets, listeners)

### Manual Verification Checklist

Each `MANUAL_VERIFICATION.md` must include:
- [ ] Overview of what's being tested
- [ ] List of functions/components to verify
- [ ] Step-by-step UI testing instructions
- [ ] Expected toast notifications
- [ ] Expected console logs
- [ ] Database verification steps
- [ ] Edge cases table
- [ ] Common issues & troubleshooting
- [ ] Test checklist

---

**üéØ Your mission: Create tests that reveal problems, guide refactoring, and maintain code quality. Never mask problems with complex mocks. Provide clear manual verification guides for QA and developers.**
